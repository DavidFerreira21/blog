<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Série k8s: Fundamentos de Kubernetes | David Ferreira — Cloud & Platform Engineering</title>
<meta name=keywords content="k8s,kubernetes,fundamentos,containers,cloud"><meta name=description content="Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura."><meta name=author content><link rel=canonical href=https://davidferreira21.github.io/blog/posts/ks8-fundamentos/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.76c31460301d23242a7cfd53490919c0aa3e70cf3554826e69bcd94d75df1518.css integrity="sha256-dsMUYDAdIyQqfP1TSQkZwKo+cM81VIJuabzZTXXfFRg=" rel="preload stylesheet" as=style><link rel=icon href=https://davidferreira21.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://davidferreira21.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://davidferreira21.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://davidferreira21.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://davidferreira21.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://davidferreira21.github.io/blog/posts/ks8-fundamentos/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://davidferreira21.github.io/blog/posts/ks8-fundamentos/"><meta property="og:site_name" content="David Ferreira — Cloud & Platform Engineering"><meta property="og:title" content="Série k8s: Fundamentos de Kubernetes"><meta property="og:description" content="Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura."><meta property="og:locale" content="pt-br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-29T09:00:00-03:00"><meta property="article:modified_time" content="2026-01-29T09:00:00-03:00"><meta property="article:tag" content="K8s"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Fundamentos"><meta property="article:tag" content="Containers"><meta property="article:tag" content="Cloud"><meta property="og:image" content="https://davidferreira21.github.io/blog/images/k8s-fundamentos.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://davidferreira21.github.io/blog/images/k8s-fundamentos.png"><meta name=twitter:title content="Série k8s: Fundamentos de Kubernetes"><meta name=twitter:description content="Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://davidferreira21.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Série k8s: Fundamentos de Kubernetes","item":"https://davidferreira21.github.io/blog/posts/ks8-fundamentos/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Série k8s: Fundamentos de Kubernetes","name":"Série k8s: Fundamentos de Kubernetes","description":"Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura.","keywords":["k8s","kubernetes","fundamentos","containers","cloud"],"articleBody":"Série k8s: Fundamentos de Kubernetes Esta é a primeira parte de uma série de posts sobre Kubernetes. A ideia é construir uma base sólida, do básico ao avançado, passando por arquitetura, workloads, rede, storage, segurança, observabilidade e boas práticas de operação.\nSe você está começando agora, este post é o ponto de partida. Se já usa Kubernetes no dia a dia, use como revisão rápida dos conceitos fundamentais e como referência quando surgir dúvida.\nSobre esta série Nesta série vamos abordar, de forma direta e prática:\nConceitos base de containers e runtimes Componentes do Kubernetes e arquitetura do cluster Workloads (pods, deployments, jobs) Rede e exposição de serviços Storage e persistência Segurança e boas práticas operacionais Observabilidade e troubleshooting Para quem é este conteúdo Quem está começando em Kubernetes e quer uma base sólida Quem já usa k8s, mas precisa organizar os conceitos Quem quer material de referência para o dia a dia O que é o Kubernetes? Kubernetes é um orquestrador de contêineres: ele decide onde executar cada aplicação, como manter tudo saudável e como escalar quando necessário. Pense nele como o “sistema operacional” do seu cluster.\nO projeto foi desenvolvido pela Google, em meados de 2014, como open source, com base no aprendizado do projeto Borg. Alguns outros produtos, como Apache Mesos e Cloud Foundry, também surgiram dessa mesma linha de pesquisa.\nComo Kubernetes é uma palavra difícil de se pronunciar e escrever, a comunidade apelidou de k8s, seguindo o padrão i18n (a letra “k” seguida por oito letras e o “s” no final), pronunciando-se “kates”.\nAlguns sites que devemos visitar Abaixo estão os sites oficiais do projeto:\nhttps://kubernetes.io https://github.com/kubernetes/kubernetes/ https://github.com/kubernetes/kubernetes/issues E aqui estão as páginas oficiais das certificações (CKA, CKAD e CKS):\nhttps://www.cncf.io/certification/cka/ https://www.cncf.io/certification/ckad/ https://www.cncf.io/certification/cks/ O container engine Antes de aprofundar no Kubernetes, vale entender algumas peças do ecossistema. Uma delas é o container engine.\nO container engine gerencia imagens, volumes e redes, garantindo o isolamento dos recursos que os containers usam (CPU, memória, storage, rede, etc.). É a camada que executa containers no dia a dia.\nHoje existem várias opções de container engine, que até pouco tempo atrás eram quase sinônimo de Docker.\nOpções como Docker, CRI-O e Podman são bem conhecidas e preparadas para ambiente produtivo. O Docker é o mais popular e utiliza o containerd como runtime.\nContainer runtime? O que é isso?\nCalma que vou explicar já já, mas antes temos que falar sobre a OCI. :)\nOCI — Open Container Initiative A OCI é uma organização sem fins lucrativos que define padrões para containers, garantindo que funcionem em qualquer ambiente. Foi fundada em 2015 por Docker, CoreOS, Google, IBM, Microsoft, Red Hat e VMware, e hoje faz parte da Linux Foundation.\nO principal projeto da OCI é o runc, um runtime de baixo nível usado por diferentes container engines, como o Docker.\nO runc é open source, escrito em Go, e seu código está disponível no GitHub.\nAgora sim podemos falar sobre o que é o container runtime.\nO container runtime Para executar containers nos nós, é necessário ter um container runtime instalado em cada um deles. É ele quem “roda” o container de fato.\nQuando você usa Docker ou Podman, está usando um container runtime por trás. Em outras palavras: o engine faz a gestão, e o runtime executa.\nExistem quatro tipos comuns de container runtime:\nLow-level: são os runtimes “de base”, que conversam diretamente com o kernel e criam os processos dos containers. Exemplos: runc, crun e runsc. High-level: são camadas que gerenciam o ciclo de vida do container e usam um runtime low-level por baixo. Exemplos: containerd, CRI-O e Podman. Sandbox: adicionam uma camada extra de isolamento para segurança (útil em ambientes multi-tenant). O gVisor é um exemplo desse tipo. Virtualized: executam containers dentro de VMs leves para aumentar isolamento. A segurança é maior, mas há custo de performance. O Kata Containers é um exemplo. Arquitetura do k8s Assim como outros orquestradores, o k8s segue o modelo control plane + workers. O control plane gerencia o cluster; os workers executam as aplicações. Em produção, recomenda-se ao menos três nós de control plane para alta disponibilidade.\nÉ possível rodar um cluster em um único nó, mas apenas para estudos e labs.\nSe você quiser usar Kubernetes localmente, existem várias opções que criam um cluster usando VMs ou Docker. Exemplos:\nKind: cluster Kubernetes com containers Docker. Útil para estudos, desenvolvimento e testes. Não usar em produção. Minikube: cluster local com um nó. Não usar em produção. MicroK8s: pode ser usado em produção, especialmente para Edge e IoT. k3s: distribuição leve, executa inclusive em Raspberry Pi. k0s: distribuição em binário único, focada em simplicidade. Pode ser usada em produção. Componentes principais Os componentes do Kubernetes se dividem em control plane e workers. O control plane toma decisões globais (como agendamento) e reage a eventos do cluster; os workers executam as cargas.\nControl plane\nkube-apiserver: é o “front door” do cluster. Recebe todas as requisições do kubectl e dos demais componentes. Valida, autentica e autoriza as chamadas antes de gravar ou consultar estado no etcd. etcd: banco chave‑valor distribuído que guarda todo o estado do cluster (objetos, configurações e status). É crítico para recuperação de desastres; por isso backup é obrigatório em produção. kube-scheduler: escolhe em qual nó um Pod vai rodar. Ele avalia recursos disponíveis, afinidades, tolerations, políticas e outras restrições para decidir o melhor nó. kube-controller-manager: executa controladores que garantem o estado desejado do cluster. Ex.: se um Deployment quer 3 réplicas e só existem 2, o controller cria a terceira. cloud-controller-manager: integra o cluster ao provedor de nuvem. Ele cria e gerencia recursos externos (load balancers, rotas, volumes) usando a API do cloud provider. Workers\nkubelet: agente em cada nó que “materializa” os Pods. Ele conversa com o runtime, inicia containers, monitora saúde e reporta status ao control plane. kube-proxy: implementa regras de rede para Services. Ele cria o encaminhamento (iptables/ipvs) que faz o tráfego chegar ao Pod correto. Portas que devemos nos preocupar Control plane\nProtocol Direction Port Range Purpose Used By TCP Inbound 6443* Kubernetes API server All TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 10251 kube-scheduler Self TCP Inbound 10252 kube-controller-manager Self Toda porta marcada por * é customizável. Se você alterar, garanta que a porta também esteja liberada no firewall.\nWorkers\nProtocol Direction Port Range Purpose Used By TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 30000-32767 NodePort Services All Conceitos-chave do k8s O k8s não gerencia containers diretamente; ele organiza tudo dentro de Pods. Abaixo estão os conceitos mais usados no dia a dia, com uma explicação direta do “para quê” de cada um:\nPod: menor unidade do k8s. Agrupa um ou mais containers que compartilham rede, volumes e ciclo de vida. Se o Pod morrer, ele é recriado. Deployment: forma padrão de rodar aplicações. Garante número de réplicas, faz rollouts/rollbacks e mantém a aplicação disponível durante atualizações. ReplicaSet: é o motor por trás do Deployment. Ele garante que a quantidade desejada de Pods esteja sempre rodando. Service: cria um endereço estável para acessar Pods. Pode expor internamente (ClusterIP) ou externamente (NodePort/LoadBalancer). Volume: define como dados são armazenados e compartilhados entre containers. Pode ser temporário (emptyDir) ou persistente (PV/PVC). Probes: checagens de saúde dos containers. Liveness reinicia, readiness controla se recebe tráfego e startup dá tempo extra para inicialização. Ingress: camada HTTP/HTTPS que define regras de entrada para múltiplos serviços, usando hosts, paths e TLS. Secret: guarda dados sensíveis (tokens, senhas, chaves). Evita hardcode em manifestos. ConfigMap: guarda configurações não sensíveis em chave/valor para aplicações. Nos próximos posts da série, vou detalhar pods, deployments e services, com exemplos práticos e manifests reais.\n","wordCount":"1281","inLanguage":"en","image":"https://davidferreira21.github.io/blog/images/k8s-fundamentos.png","datePublished":"2026-01-29T09:00:00-03:00","dateModified":"2026-01-29T09:00:00-03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://davidferreira21.github.io/blog/posts/ks8-fundamentos/"},"publisher":{"@type":"Organization","name":"David Ferreira — Cloud \u0026 Platform Engineering","logo":{"@type":"ImageObject","url":"https://davidferreira21.github.io/blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://davidferreira21.github.io/blog/ accesskey=h title="David Ferreira — Cloud & Platform Engineering (Alt + H)">David Ferreira — Cloud & Platform Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://davidferreira21.github.io/blog/ title=Início><span>Início</span></a></li><li><a href=https://davidferreira21.github.io/blog/posts/ title=Posts><span>Posts</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=arquitetura" title=Arquitetura><span>Arquitetura</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=cloud" title=Cloud><span>Cloud</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=devops" title=DevOps><span>DevOps</span></a></li><li><a href=https://davidferreira21.github.io/blog/sobre/ title=Sobre><span>Sobre</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Série k8s: Fundamentos de Kubernetes</h1><div class=post-description>Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura.</div><div class=post-meta><span title='2026-01-29 09:00:00 -0300 -0300'>January 29, 2026</span>&nbsp;·&nbsp;<span>7 min</span></div></header><figure class=entry-cover><img loading=eager src=https://davidferreira21.github.io/blog/images/k8s-fundamentos.png alt="Ilustração sobre fundamentos de Kubernetes"></figure><div class=post-content><h1 id=série-k8s-fundamentos-de-kubernetes>Série k8s: Fundamentos de Kubernetes<a hidden class=anchor aria-hidden=true href=#série-k8s-fundamentos-de-kubernetes>#</a></h1><p>Esta é a primeira parte de uma série de posts sobre Kubernetes. A ideia é construir uma base sólida, do básico ao avançado, passando por arquitetura, workloads, rede, storage, segurança, observabilidade e boas práticas de operação.</p><p>Se você está começando agora, este post é o ponto de partida. Se já usa Kubernetes no dia a dia, use como revisão rápida dos conceitos fundamentais e como referência quando surgir dúvida.</p><h2 id=sobre-esta-série>Sobre esta série<a hidden class=anchor aria-hidden=true href=#sobre-esta-série>#</a></h2><p>Nesta série vamos abordar, de forma direta e prática:</p><ul><li>Conceitos base de containers e runtimes</li><li>Componentes do Kubernetes e arquitetura do cluster</li><li>Workloads (pods, deployments, jobs)</li><li>Rede e exposição de serviços</li><li>Storage e persistência</li><li>Segurança e boas práticas operacionais</li><li>Observabilidade e troubleshooting</li></ul><h2 id=para-quem-é-este-conteúdo>Para quem é este conteúdo<a hidden class=anchor aria-hidden=true href=#para-quem-é-este-conteúdo>#</a></h2><ul><li>Quem está começando em Kubernetes e quer uma base sólida</li><li>Quem já usa k8s, mas precisa organizar os conceitos</li><li>Quem quer material de referência para o dia a dia</li></ul><h2 id=o-que-é-o-kubernetes>O que é o Kubernetes?<a hidden class=anchor aria-hidden=true href=#o-que-é-o-kubernetes>#</a></h2><p>Kubernetes é um orquestrador de contêineres: ele decide <strong>onde</strong> executar cada aplicação, <strong>como</strong> manter tudo saudável e <strong>como</strong> escalar quando necessário. Pense nele como o “sistema operacional” do seu cluster.</p><p>O projeto foi desenvolvido pela Google, em meados de 2014, como <em>open source</em>, com base no aprendizado do projeto Borg. Alguns outros produtos, como Apache Mesos e Cloud Foundry, também surgiram dessa mesma linha de pesquisa.</p><p>Como Kubernetes é uma palavra difícil de se pronunciar e escrever, a comunidade apelidou de <strong>k8s</strong>, seguindo o padrão i18n (a letra &ldquo;k&rdquo; seguida por oito letras e o &ldquo;s&rdquo; no final), pronunciando-se “kates”.</p><h3 id=alguns-sites-que-devemos-visitar>Alguns sites que devemos visitar<a hidden class=anchor aria-hidden=true href=#alguns-sites-que-devemos-visitar>#</a></h3><p>Abaixo estão os sites oficiais do projeto:</p><ul><li><a href=https://kubernetes.io>https://kubernetes.io</a></li><li><a href=https://github.com/kubernetes/kubernetes/>https://github.com/kubernetes/kubernetes/</a></li><li><a href=https://github.com/kubernetes/kubernetes/issues>https://github.com/kubernetes/kubernetes/issues</a></li></ul><p>E aqui estão as páginas oficiais das certificações (CKA, CKAD e CKS):</p><ul><li><a href=https://www.cncf.io/certification/cka/>https://www.cncf.io/certification/cka/</a></li><li><a href=https://www.cncf.io/certification/ckad/>https://www.cncf.io/certification/ckad/</a></li><li><a href=https://www.cncf.io/certification/cks/>https://www.cncf.io/certification/cks/</a></li></ul><h2 id=o-container-engine>O container engine<a hidden class=anchor aria-hidden=true href=#o-container-engine>#</a></h2><p>Antes de aprofundar no Kubernetes, vale entender algumas peças do ecossistema. Uma delas é o <strong>container engine</strong>.</p><p>O <em>container engine</em> gerencia imagens, volumes e redes, garantindo o isolamento dos recursos que os containers usam (CPU, memória, storage, rede, etc.). É a camada que executa containers no dia a dia.</p><p>Hoje existem várias opções de <em>container engine</em>, que até pouco tempo atrás eram quase sinônimo de Docker.</p><p>Opções como Docker, CRI-O e Podman são bem conhecidas e preparadas para ambiente produtivo. O Docker é o mais popular e utiliza o containerd como runtime.</p><p><strong>Container runtime?</strong> O que é isso?</p><p>Calma que vou explicar já já, mas antes temos que falar sobre a OCI. :)</p><h3 id=oci--open-container-initiative>OCI — Open Container Initiative<a hidden class=anchor aria-hidden=true href=#oci--open-container-initiative>#</a></h3><p>A OCI é uma organização sem fins lucrativos que define padrões para containers, garantindo que funcionem em qualquer ambiente. Foi fundada em 2015 por Docker, CoreOS, Google, IBM, Microsoft, Red Hat e VMware, e hoje faz parte da Linux Foundation.</p><p>O principal projeto da OCI é o <em>runc</em>, um runtime de baixo nível usado por diferentes <em>container engines</em>, como o Docker.</p><p>O <em>runc</em> é open source, escrito em Go, e seu código está disponível no GitHub.</p><p>Agora sim podemos falar sobre o que é o container runtime.</p><h3 id=o-container-runtime>O container runtime<a hidden class=anchor aria-hidden=true href=#o-container-runtime>#</a></h3><p>Para executar containers nos nós, é necessário ter um <em>container runtime</em> instalado em cada um deles. É ele quem “roda” o container de fato.</p><p>Quando você usa Docker ou Podman, está usando um <em>container runtime</em> por trás. Em outras palavras: o engine faz a gestão, e o runtime executa.</p><p>Existem quatro tipos comuns de <em>container runtime</em>:</p><ul><li><strong>Low-level</strong>: são os runtimes “de base”, que conversam diretamente com o kernel e criam os processos dos containers. Exemplos: runc, crun e runsc.</li><li><strong>High-level</strong>: são camadas que gerenciam o ciclo de vida do container e usam um runtime low-level por baixo. Exemplos: containerd, CRI-O e Podman.</li><li><strong>Sandbox</strong>: adicionam uma camada extra de isolamento para segurança (útil em ambientes multi-tenant). O gVisor é um exemplo desse tipo.</li><li><strong>Virtualized</strong>: executam containers dentro de VMs leves para aumentar isolamento. A segurança é maior, mas há custo de performance. O Kata Containers é um exemplo.</li></ul><h2 id=arquitetura-do-k8s>Arquitetura do k8s<a hidden class=anchor aria-hidden=true href=#arquitetura-do-k8s>#</a></h2><p>Assim como outros orquestradores, o k8s segue o modelo <strong>control plane + workers</strong>. O control plane gerencia o cluster; os workers executam as aplicações. Em produção, recomenda-se ao menos três nós de control plane para alta disponibilidade.</p><p>É possível rodar um cluster em um único nó, mas apenas para estudos e labs.</p><p>Se você quiser usar Kubernetes localmente, existem várias opções que criam um cluster usando VMs ou Docker. Exemplos:</p><ul><li><a href=https://kind.sigs.k8s.io/docs/user/quick-start>Kind</a>: cluster Kubernetes com containers Docker. Útil para estudos, desenvolvimento e testes. <strong>Não usar em produção</strong>.</li><li><a href=https://github.com/kubernetes/minikube>Minikube</a>: cluster local com um nó. <strong>Não usar em produção</strong>.</li><li><a href=https://microk8s.io>MicroK8s</a>: pode ser usado em produção, especialmente para Edge e IoT.</li><li><a href=https://k3s.io>k3s</a>: distribuição leve, executa inclusive em Raspberry Pi.</li><li><a href=https://k0sproject.io>k0s</a>: distribuição em binário único, focada em simplicidade. <strong>Pode ser usada em produção</strong>.</li></ul><h3 id=componentes-principais>Componentes principais<a hidden class=anchor aria-hidden=true href=#componentes-principais>#</a></h3><p>Os componentes do Kubernetes se dividem em <strong>control plane</strong> e <strong>workers</strong>. O control plane toma decisões globais (como agendamento) e reage a eventos do cluster; os workers executam as cargas.</p><p><strong>Control plane</strong></p><ul><li><strong>kube-apiserver</strong>: é o “front door” do cluster. Recebe todas as requisições do <code>kubectl</code> e dos demais componentes. Valida, autentica e autoriza as chamadas antes de gravar ou consultar estado no etcd.</li><li><strong>etcd</strong>: banco chave‑valor distribuído que guarda <strong>todo o estado do cluster</strong> (objetos, configurações e status). É crítico para recuperação de desastres; por isso backup é obrigatório em produção.</li><li><strong>kube-scheduler</strong>: escolhe em qual nó um Pod vai rodar. Ele avalia recursos disponíveis, afinidades, tolerations, políticas e outras restrições para decidir o melhor nó.</li><li><strong>kube-controller-manager</strong>: executa controladores que garantem o estado desejado do cluster. Ex.: se um Deployment quer 3 réplicas e só existem 2, o controller cria a terceira.</li><li><strong>cloud-controller-manager</strong>: integra o cluster ao provedor de nuvem. Ele cria e gerencia recursos externos (load balancers, rotas, volumes) usando a API do cloud provider.</li></ul><p><strong>Workers</strong></p><ul><li><strong>kubelet</strong>: agente em cada nó que “materializa” os Pods. Ele conversa com o runtime, inicia containers, monitora saúde e reporta status ao control plane.</li><li><strong>kube-proxy</strong>: implementa regras de rede para Services. Ele cria o encaminhamento (iptables/ipvs) que faz o tráfego chegar ao Pod correto.</li></ul><p><img alt="Arquitetura do Kubernetes" loading=lazy src=https://davidferreira21.github.io/blog/images/k8s-arch.png></p><h2 id=portas-que-devemos-nos-preocupar>Portas que devemos nos preocupar<a hidden class=anchor aria-hidden=true href=#portas-que-devemos-nos-preocupar>#</a></h2><p><strong>Control plane</strong></p><table><thead><tr><th>Protocol</th><th>Direction</th><th>Port Range</th><th>Purpose</th><th>Used By</th></tr></thead><tbody><tr><td>TCP</td><td>Inbound</td><td>6443*</td><td>Kubernetes API server</td><td>All</td></tr><tr><td>TCP</td><td>Inbound</td><td>2379-2380</td><td>etcd server client API</td><td>kube-apiserver, etcd</td></tr><tr><td>TCP</td><td>Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td>TCP</td><td>Inbound</td><td>10251</td><td>kube-scheduler</td><td>Self</td></tr><tr><td>TCP</td><td>Inbound</td><td>10252</td><td>kube-controller-manager</td><td>Self</td></tr></tbody></table><p><em>Toda porta marcada por * é customizável. Se você alterar, garanta que a porta também esteja liberada no firewall.</em></p><p><strong>Workers</strong></p><table><thead><tr><th>Protocol</th><th>Direction</th><th>Port Range</th><th>Purpose</th><th>Used By</th></tr></thead><tbody><tr><td>TCP</td><td>Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td>TCP</td><td>Inbound</td><td>30000-32767</td><td>NodePort</td><td>Services All</td></tr></tbody></table><h2 id=conceitos-chave-do-k8s>Conceitos-chave do k8s<a hidden class=anchor aria-hidden=true href=#conceitos-chave-do-k8s>#</a></h2><p>O k8s não gerencia containers diretamente; ele organiza tudo dentro de <strong>Pods</strong>. Abaixo estão os conceitos mais usados no dia a dia, com uma explicação direta do “para quê” de cada um:</p><ul><li><strong>Pod</strong>: menor unidade do k8s. Agrupa um ou mais containers que compartilham rede, volumes e ciclo de vida. Se o Pod morrer, ele é recriado.</li><li><strong>Deployment</strong>: forma padrão de rodar aplicações. Garante número de réplicas, faz rollouts/rollbacks e mantém a aplicação disponível durante atualizações.</li><li><strong>ReplicaSet</strong>: é o motor por trás do Deployment. Ele garante que a quantidade desejada de Pods esteja sempre rodando.</li><li><strong>Service</strong>: cria um endereço estável para acessar Pods. Pode expor internamente (ClusterIP) ou externamente (NodePort/LoadBalancer).</li><li><strong>Volume</strong>: define como dados são armazenados e compartilhados entre containers. Pode ser temporário (emptyDir) ou persistente (PV/PVC).</li><li><strong>Probes</strong>: checagens de saúde dos containers. <em>Liveness</em> reinicia, <em>readiness</em> controla se recebe tráfego e <em>startup</em> dá tempo extra para inicialização.</li><li><strong>Ingress</strong>: camada HTTP/HTTPS que define regras de entrada para múltiplos serviços, usando hosts, paths e TLS.</li><li><strong>Secret</strong>: guarda dados sensíveis (tokens, senhas, chaves). Evita hardcode em manifestos.</li><li><strong>ConfigMap</strong>: guarda configurações não sensíveis em chave/valor para aplicações.</li></ul><hr><p>Nos próximos posts da série, vou detalhar <strong>pods, deployments e services</strong>, com exemplos práticos e manifests reais.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://davidferreira21.github.io/blog/tags/k8s/>K8s</a></li><li><a href=https://davidferreira21.github.io/blog/tags/kubernetes/>Kubernetes</a></li><li><a href=https://davidferreira21.github.io/blog/tags/fundamentos/>Fundamentos</a></li><li><a href=https://davidferreira21.github.io/blog/tags/containers/>Containers</a></li><li><a href=https://davidferreira21.github.io/blog/tags/cloud/>Cloud</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=custom-footer><div class=custom-footer__inner><div class=custom-footer__cta><p class=custom-footer__title>Quer receber atualizações?</p><p class=custom-footer__subtitle>Inscreva-se para não perder novos posts sobre cloud, arquitetura e devops.</p></div><form class=custom-footer__subscribe action=# method=post><label for=subscribe-email>Newsletter</label><div class=custom-footer__subscribe-row><input id=subscribe-email name=email type=email placeholder="Seu melhor e-mail" required>
<button type=submit>Assinar</button></div></form></div><div class=custom-footer__divider></div><div class=custom-footer__bottom><div class=custom-footer__brand><span class=custom-footer__name>David Ferreira — Cloud & Platform Engineering</span>
<span class=custom-footer__theme>Cloud • Platform Engineering • DevOps</span></div><div class=custom-footer__links><a class=custom-footer__link href=/blog/sobre/>Sobre mim</a>
<a class=custom-footer__link href=https://www.linkedin.com/in/davidferreirams/ rel=noopener target=_blank><span class=custom-footer__icon aria-hidden=true><svg viewBox="0 0 24 24" role="img" aria-label="LinkedIn"><path d="M20.45 20.45H17V14.86c0-1.33-.02-3.04-1.85-3.04-1.85.0-2.13 1.45-2.13 2.95v5.68H9.56V9h3.32v1.56h.05c.46-.88 1.58-1.8 3.26-1.8 3.49.0 4.13 2.3 4.13 5.29v6.4zM5.34 7.43a1.94 1.94.0 110-3.88 1.94 1.94.0 010 3.88zM6.95 20.45H3.72V9H6.95v11.45z"/></svg>
</span>LinkedIn</a></div></div></div><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>