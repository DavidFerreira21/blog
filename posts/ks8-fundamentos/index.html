<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Série k8s: Fundamentos de Kubernetes | David Ferreira — Cloud & Platform Engineering</title>
<meta name=keywords content="k8s,kubernetes,fundamentos,containers,cloud"><meta name=description content="Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura."><meta name=author content><link rel=canonical href=https://davidferreira21.github.io/blog/posts/ks8-fundamentos/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.45f79e6c2d3ee5beb380637ec15ec3e9c68cbc883075b8192a307337c68f8084.css integrity="sha256-RfeebC0+5b6zgGN+wV7D6caMvIgwdbgZKjBzN8aPgIQ=" rel="preload stylesheet" as=style><link rel=icon href=https://davidferreira21.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://davidferreira21.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://davidferreira21.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://davidferreira21.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://davidferreira21.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://davidferreira21.github.io/blog/posts/ks8-fundamentos/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://davidferreira21.github.io/blog/posts/ks8-fundamentos/"><meta property="og:site_name" content="David Ferreira — Cloud & Platform Engineering"><meta property="og:title" content="Série k8s: Fundamentos de Kubernetes"><meta property="og:description" content="Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura."><meta property="og:locale" content="pt-br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-29T09:00:00-03:00"><meta property="article:modified_time" content="2026-01-29T09:00:00-03:00"><meta property="article:tag" content="K8s"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Fundamentos"><meta property="article:tag" content="Containers"><meta property="article:tag" content="Cloud"><meta property="og:image" content="https://davidferreira21.github.io/blog/images/k8s-fundamentos.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://davidferreira21.github.io/blog/images/k8s-fundamentos.png"><meta name=twitter:title content="Série k8s: Fundamentos de Kubernetes"><meta name=twitter:description content="Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://davidferreira21.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Série k8s: Fundamentos de Kubernetes","item":"https://davidferreira21.github.io/blog/posts/ks8-fundamentos/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Série k8s: Fundamentos de Kubernetes","name":"Série k8s: Fundamentos de Kubernetes","description":"Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura.","keywords":["k8s","kubernetes","fundamentos","containers","cloud"],"articleBody":"Esta é a primeira parte de uma série de posts sobre Kubernetes. A ideia é construir uma base sólida, do básico ao avançado, passando por arquitetura, workloads, rede, storage, segurança, observabilidade e boas práticas de operação.\nSe você está começando agora, este post é o ponto de partida. Se já usa Kubernetes no dia a dia, use como revisão rápida dos conceitos fundamentais.\nSobre esta série Nesta série vamos abordar alguns fundamentos:\nConceitos base de containers e runtimes Componentes do Kubernetes e arquitetura do cluster Workloads (pods, deployments, jobs) Rede e exposição de serviços Storage e persistência Segurança e boas práticas operacionais Observabilidade e troubleshooting Para quem é este conteúdo Quem está começando em Kubernetes e quer uma base sólida Quem já usa k8s, mas precisa organizar os conceitos Quem quer material de referência para o dia a dia O que é o Kubernetes? O projeto Kubernetes foi desenvolvido pela Google, em meados de 2014, para atuar como um orquestrador de contêineres para a empresa. O Kubernetes (k8s), cujo termo em grego significa “timoneiro”, é um projeto open source que conta com design e desenvolvimento baseados no projeto Borg, que também é da Google. Alguns outros produtos disponíveis no mercado, tais como o Apache Mesos e o Cloud Foundry, também surgiram a partir do projeto Borg.\nComo Kubernetes é uma palavra difícil de se pronunciar e escrever, a comunidade simplesmente o apelidou de k8s, seguindo o padrão i18n (a letra “k” seguida por oito letras e o “s” no final), pronunciando-se simplesmente “kates”.\nAlguns sites que devemos visitar Abaixo temos os sites oficiais do projeto do Kubernetes:\nhttps://kubernetes.io https://github.com/kubernetes/kubernetes/ https://github.com/kubernetes/kubernetes/issues Abaixo temos as páginas oficiais das certificações do Kubernetes (CKA, CKAD e CKS):\nhttps://www.cncf.io/certification/cka/ https://www.cncf.io/certification/ckad/ https://www.cncf.io/certification/cks/ O container engine Antes de começar a falar um pouco mais sobre o Kubernetes, precisamos entender alguns componentes importantes no ecossistema. Um desses componentes é o container engine.\nO container engine é o responsável por gerenciar imagens e volumes, garantindo o isolamento dos recursos que os containers estão utilizando (CPU, memória, storage, rede, etc.).\nHoje temos diversas opções para se utilizar como container engine, que até pouco tempo atrás eram quase sinônimo de Docker.\nOpções como Docker, CRI-O e Podman são bem conhecidas e preparadas para ambiente produtivo. O Docker, como todos sabem, é o container engine mais popular e utiliza o containerd como runtime.\nContainer runtime? O que é isso?\nCalma que vou explicar já já, mas antes temos que falar sobre a OCI. :)\nOCI — Open Container Initiative A OCI é uma organização sem fins lucrativos que tem como objetivo padronizar a criação de containers, para que possam ser executados em qualquer ambiente. A OCI foi fundada em 2015 pela Docker, CoreOS, Google, IBM, Microsoft, Red Hat e VMware e hoje faz parte da Linux Foundation.\nO principal projeto criado pela OCI é o runc, que é o principal container runtime de baixo nível, e utilizado por diferentes container engines, como o Docker.\nO runc é um projeto open source, escrito em Go, e seu código está disponível no GitHub.\nAgora sim já podemos falar sobre o que é o container runtime.\nO container runtime Para que seja possível executar containers nos nós, é necessário ter um container runtime instalado em cada um deles.\nO container runtime é o responsável por executar os containers nos nós. Quando você está utilizando Docker ou Podman para executar containers na sua máquina, você está fazendo uso de algum container runtime (ou melhor, o seu container engine está fazendo uso de algum runtime).\nTemos quatro tipos de container runtime:\nLow-level: executados diretamente pelo Kernel, como runc, crun e runsc. High-level: executados por um container engine, como containerd, CRI-O e Podman. Sandbox: executados por um container engine e responsáveis por executar containers de forma segura, usando uma camada adicional. O gVisor é um exemplo desse tipo. Virtualized: executados por um container engine e responsáveis por executar containers de forma segura em máquinas virtuais. A performance é menor do que quando são executados nativamente. O Kata Containers é um exemplo. Arquitetura do k8s Assim como os demais orquestradores disponíveis, o k8s segue um modelo control plane/workers, constituindo assim um cluster, onde para seu funcionamento é recomendado no mínimo três nós: o nó control plane, responsável (por padrão) pelo gerenciamento do cluster, e os demais como workers, executores das aplicações que queremos executar sobre esse cluster.\nÉ possível criar um cluster Kubernetes rodando em apenas um nó, porém é recomendado somente para fins de estudos e nunca para produção.\nCaso você queira utilizar o Kubernetes em sua máquina local, existem diversas soluções que criam um cluster Kubernetes usando VMs ou Docker. Alguns exemplos:\nKind: cluster Kubernetes com containers Docker. Útil para estudos, desenvolvimento e testes. Não usar em produção. Minikube: cluster local com um nó. Não usar em produção. MicroK8s: pode ser usado em produção, especialmente para Edge e IoT. k3s: distribuição leve, executa inclusive em Raspberry Pi. k0s: distribuição em binário único, focada em simplicidade. Pode ser usada em produção. Componentes principais API Server: fornece a API (JSON/HTTP) do cluster. A comunicação com o cluster ocorre principalmente via kubectl. etcd: datastore chave-valor distribuído que armazena o estado do cluster. Por padrão roda no control plane. Scheduler: escolhe o nó onde um pod será executado, baseado em recursos e políticas. Controller Manager: garante que o estado atual do cluster converge para o estado desejado (ex.: número de réplicas). Kubelet: é o agente do k8s que roda nos nós workers. Ele gerencia os pods em cada nó. Kube-proxy: responsável pelo roteamento e pelo balanceamento de tráfego dentro do nó. Portas que devemos nos preocupar Control plane\nProtocol Direction Port Range Purpose Used By TCP Inbound 6443* Kubernetes API server All TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 10251 kube-scheduler Self TCP Inbound 10252 kube-controller-manager Self Toda porta marcada por * é customizável, você precisa se certificar que a porta alterada também esteja aberta.\nWorkers\nProtocol Direction Port Range Purpose Used By TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 30000-32767 NodePort Services All Conceitos-chave do k8s É importante saber que o k8s gerencia contêineres de forma diferente de outros orquestradores, como Docker Swarm. Ele não trata contêineres diretamente, mas os organiza dentro de pods. Vamos aos principais conceitos:\nPod: menor objeto do k8s. Agrupa um ou mais contêineres que compartilham recursos. Deployment: garante réplicas e gerencia o ciclo de vida das aplicações. ReplicaSet: mantém a quantidade desejada de pods em execução. Services: expõem aplicações via ClusterIP, NodePort ou LoadBalancer. Volumes: armazenamento compartilhado/persistente para pods. Probes: checagens de saúde (liveness, readiness, startup). Ingress: regras HTTP/HTTPS para expor serviços com host/path/TLS. Secrets: dados sensíveis (tokens, senhas, chaves) em base64. ConfigMap: configurações não sensíveis em chave/valor. Nos próximos posts da série, vou detalhar pods, deployments e services, com exemplos práticos e manifests reais.\n","wordCount":"1145","inLanguage":"en","image":"https://davidferreira21.github.io/blog/images/k8s-fundamentos.png","datePublished":"2026-01-29T09:00:00-03:00","dateModified":"2026-01-29T09:00:00-03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://davidferreira21.github.io/blog/posts/ks8-fundamentos/"},"publisher":{"@type":"Organization","name":"David Ferreira — Cloud \u0026 Platform Engineering","logo":{"@type":"ImageObject","url":"https://davidferreira21.github.io/blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://davidferreira21.github.io/blog/ accesskey=h title="David Ferreira — Cloud & Platform Engineering (Alt + H)">David Ferreira — Cloud & Platform Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://davidferreira21.github.io/blog/blog/ title=Início><span>Início</span></a></li><li><a href=https://davidferreira21.github.io/blog/posts/ title=Posts><span>Posts</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=arquitetura" title=Arquitetura><span>Arquitetura</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=cloud" title=Cloud><span>Cloud</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=devops" title=DevOps><span>DevOps</span></a></li><li><a href=https://davidferreira21.github.io/blog/sobre/ title=Sobre><span>Sobre</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Série k8s: Fundamentos de Kubernetes</h1><div class=post-description>Início da série de Kubernetes: conceitos base, runtimes, componentes e visão geral da arquitetura.</div><div class=post-meta><span title='2026-01-29 09:00:00 -0300 -0300'>January 29, 2026</span>&nbsp;·&nbsp;<span>6 min</span></div></header><figure class=entry-cover><img loading=eager src=https://davidferreira21.github.io/blog/images/k8s-fundamentos.png alt="Ilustração sobre fundamentos de Kubernetes"></figure><div class=post-content><p>Esta é a primeira parte de uma série de posts sobre Kubernetes. A ideia é construir uma base sólida, do básico ao avançado, passando por arquitetura, workloads, rede, storage, segurança, observabilidade e boas práticas de operação.</p><p>Se você está começando agora, este post é o ponto de partida. Se já usa Kubernetes no dia a dia, use como revisão rápida dos conceitos fundamentais.</p><h2 id=sobre-esta-série>Sobre esta série<a hidden class=anchor aria-hidden=true href=#sobre-esta-série>#</a></h2><p>Nesta série vamos abordar alguns fundamentos:</p><ul><li>Conceitos base de containers e runtimes</li><li>Componentes do Kubernetes e arquitetura do cluster</li><li>Workloads (pods, deployments, jobs)</li><li>Rede e exposição de serviços</li><li>Storage e persistência</li><li>Segurança e boas práticas operacionais</li><li>Observabilidade e troubleshooting</li></ul><h2 id=para-quem-é-este-conteúdo>Para quem é este conteúdo<a hidden class=anchor aria-hidden=true href=#para-quem-é-este-conteúdo>#</a></h2><ul><li>Quem está começando em Kubernetes e quer uma base sólida</li><li>Quem já usa k8s, mas precisa organizar os conceitos</li><li>Quem quer material de referência para o dia a dia</li></ul><h2 id=o-que-é-o-kubernetes>O que é o Kubernetes?<a hidden class=anchor aria-hidden=true href=#o-que-é-o-kubernetes>#</a></h2><p>O projeto Kubernetes foi desenvolvido pela Google, em meados de 2014, para atuar como um orquestrador de contêineres para a empresa. O Kubernetes (k8s), cujo termo em grego significa &ldquo;timoneiro&rdquo;, é um projeto <em>open source</em> que conta com <em>design</em> e desenvolvimento baseados no projeto Borg, que também é da Google. Alguns outros produtos disponíveis no mercado, tais como o Apache Mesos e o Cloud Foundry, também surgiram a partir do projeto Borg.</p><p>Como Kubernetes é uma palavra difícil de se pronunciar e escrever, a comunidade simplesmente o apelidou de <strong>k8s</strong>, seguindo o padrão i18n (a letra &ldquo;k&rdquo; seguida por oito letras e o &ldquo;s&rdquo; no final), pronunciando-se simplesmente &ldquo;kates&rdquo;.</p><h3 id=alguns-sites-que-devemos-visitar>Alguns sites que devemos visitar<a hidden class=anchor aria-hidden=true href=#alguns-sites-que-devemos-visitar>#</a></h3><p>Abaixo temos os sites oficiais do projeto do Kubernetes:</p><ul><li><a href=https://kubernetes.io>https://kubernetes.io</a></li><li><a href=https://github.com/kubernetes/kubernetes/>https://github.com/kubernetes/kubernetes/</a></li><li><a href=https://github.com/kubernetes/kubernetes/issues>https://github.com/kubernetes/kubernetes/issues</a></li></ul><p>Abaixo temos as páginas oficiais das certificações do Kubernetes (CKA, CKAD e CKS):</p><ul><li><a href=https://www.cncf.io/certification/cka/>https://www.cncf.io/certification/cka/</a></li><li><a href=https://www.cncf.io/certification/ckad/>https://www.cncf.io/certification/ckad/</a></li><li><a href=https://www.cncf.io/certification/cks/>https://www.cncf.io/certification/cks/</a></li></ul><h2 id=o-container-engine>O container engine<a hidden class=anchor aria-hidden=true href=#o-container-engine>#</a></h2><p>Antes de começar a falar um pouco mais sobre o Kubernetes, precisamos entender alguns componentes importantes no ecossistema. Um desses componentes é o container engine.</p><p>O <em>container engine</em> é o responsável por gerenciar imagens e volumes, garantindo o isolamento dos recursos que os containers estão utilizando (CPU, memória, storage, rede, etc.).</p><p>Hoje temos diversas opções para se utilizar como <em>container engine</em>, que até pouco tempo atrás eram quase sinônimo de Docker.</p><p>Opções como Docker, CRI-O e Podman são bem conhecidas e preparadas para ambiente produtivo. O Docker, como todos sabem, é o container engine mais popular e utiliza o containerd como runtime.</p><p><strong>Container runtime?</strong> O que é isso?</p><p>Calma que vou explicar já já, mas antes temos que falar sobre a OCI. :)</p><h3 id=oci--open-container-initiative>OCI — Open Container Initiative<a hidden class=anchor aria-hidden=true href=#oci--open-container-initiative>#</a></h3><p>A OCI é uma organização sem fins lucrativos que tem como objetivo padronizar a criação de containers, para que possam ser executados em qualquer ambiente. A OCI foi fundada em 2015 pela Docker, CoreOS, Google, IBM, Microsoft, Red Hat e VMware e hoje faz parte da Linux Foundation.</p><p>O principal projeto criado pela OCI é o <em>runc</em>, que é o principal container runtime de baixo nível, e utilizado por diferentes <em>container engines</em>, como o Docker.</p><p>O <em>runc</em> é um projeto open source, escrito em Go, e seu código está disponível no GitHub.</p><p>Agora sim já podemos falar sobre o que é o container runtime.</p><h3 id=o-container-runtime>O container runtime<a hidden class=anchor aria-hidden=true href=#o-container-runtime>#</a></h3><p>Para que seja possível executar containers nos nós, é necessário ter um <em>container runtime</em> instalado em cada um deles.</p><p>O <em>container runtime</em> é o responsável por executar os containers nos nós. Quando você está utilizando Docker ou Podman para executar containers na sua máquina, você está fazendo uso de algum <em>container runtime</em> (ou melhor, o seu container engine está fazendo uso de algum runtime).</p><p>Temos quatro tipos de <em>container runtime</em>:</p><ul><li><strong>Low-level</strong>: executados diretamente pelo Kernel, como runc, crun e runsc.</li><li><strong>High-level</strong>: executados por um <em>container engine</em>, como containerd, CRI-O e Podman.</li><li><strong>Sandbox</strong>: executados por um <em>container engine</em> e responsáveis por executar containers de forma segura, usando uma camada adicional. O gVisor é um exemplo desse tipo.</li><li><strong>Virtualized</strong>: executados por um <em>container engine</em> e responsáveis por executar containers de forma segura em máquinas virtuais. A performance é menor do que quando são executados nativamente. O Kata Containers é um exemplo.</li></ul><h2 id=arquitetura-do-k8s>Arquitetura do k8s<a hidden class=anchor aria-hidden=true href=#arquitetura-do-k8s>#</a></h2><p>Assim como os demais orquestradores disponíveis, o k8s segue um modelo <em>control plane/workers</em>, constituindo assim um <em>cluster</em>, onde para seu funcionamento é recomendado no mínimo três nós: o nó <em>control plane</em>, responsável (por padrão) pelo gerenciamento do <em>cluster</em>, e os demais como <em>workers</em>, executores das aplicações que queremos executar sobre esse <em>cluster</em>.</p><p>É possível criar um cluster Kubernetes rodando em apenas um nó, porém é recomendado somente para fins de estudos e nunca para produção.</p><p>Caso você queira utilizar o Kubernetes em sua máquina local, existem diversas soluções que criam um cluster Kubernetes usando VMs ou Docker. Alguns exemplos:</p><ul><li><a href=https://kind.sigs.k8s.io/docs/user/quick-start>Kind</a>: cluster Kubernetes com containers Docker. Útil para estudos, desenvolvimento e testes. <strong>Não usar em produção</strong>.</li><li><a href=https://github.com/kubernetes/minikube>Minikube</a>: cluster local com um nó. <strong>Não usar em produção</strong>.</li><li><a href=https://microk8s.io>MicroK8s</a>: pode ser usado em produção, especialmente para Edge e IoT.</li><li><a href=https://k3s.io>k3s</a>: distribuição leve, executa inclusive em Raspberry Pi.</li><li><a href=https://k0sproject.io>k0s</a>: distribuição em binário único, focada em simplicidade. <strong>Pode ser usada em produção</strong>.</li></ul><h3 id=componentes-principais>Componentes principais<a hidden class=anchor aria-hidden=true href=#componentes-principais>#</a></h3><ul><li><strong>API Server</strong>: fornece a API (JSON/HTTP) do cluster. A comunicação com o cluster ocorre principalmente via <code>kubectl</code>.</li><li><strong>etcd</strong>: <em>datastore</em> chave-valor distribuído que armazena o estado do cluster. Por padrão roda no control plane.</li><li><strong>Scheduler</strong>: escolhe o nó onde um <em>pod</em> será executado, baseado em recursos e políticas.</li><li><strong>Controller Manager</strong>: garante que o estado atual do cluster converge para o estado desejado (ex.: número de réplicas).</li><li><strong>Kubelet</strong>: é o agente do k8s que roda nos nós workers. Ele gerencia os <em>pods</em> em cada nó.</li><li><strong>Kube-proxy</strong>: responsável pelo roteamento e pelo balanceamento de tráfego dentro do nó.</li></ul><h2 id=portas-que-devemos-nos-preocupar>Portas que devemos nos preocupar<a hidden class=anchor aria-hidden=true href=#portas-que-devemos-nos-preocupar>#</a></h2><p><strong>Control plane</strong></p><table><thead><tr><th>Protocol</th><th>Direction</th><th>Port Range</th><th>Purpose</th><th>Used By</th></tr></thead><tbody><tr><td>TCP</td><td>Inbound</td><td>6443*</td><td>Kubernetes API server</td><td>All</td></tr><tr><td>TCP</td><td>Inbound</td><td>2379-2380</td><td>etcd server client API</td><td>kube-apiserver, etcd</td></tr><tr><td>TCP</td><td>Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td>TCP</td><td>Inbound</td><td>10251</td><td>kube-scheduler</td><td>Self</td></tr><tr><td>TCP</td><td>Inbound</td><td>10252</td><td>kube-controller-manager</td><td>Self</td></tr></tbody></table><p><em>Toda porta marcada por * é customizável, você precisa se certificar que a porta alterada também esteja aberta.</em></p><p><strong>Workers</strong></p><table><thead><tr><th>Protocol</th><th>Direction</th><th>Port Range</th><th>Purpose</th><th>Used By</th></tr></thead><tbody><tr><td>TCP</td><td>Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td>TCP</td><td>Inbound</td><td>30000-32767</td><td>NodePort</td><td>Services All</td></tr></tbody></table><h2 id=conceitos-chave-do-k8s>Conceitos-chave do k8s<a hidden class=anchor aria-hidden=true href=#conceitos-chave-do-k8s>#</a></h2><p>É importante saber que o k8s gerencia contêineres de forma diferente de outros orquestradores, como Docker Swarm. Ele não trata contêineres diretamente, mas os organiza dentro de <em>pods</em>. Vamos aos principais conceitos:</p><ul><li><strong>Pod</strong>: menor objeto do k8s. Agrupa um ou mais contêineres que compartilham recursos.</li><li><strong>Deployment</strong>: garante réplicas e gerencia o ciclo de vida das aplicações.</li><li><strong>ReplicaSet</strong>: mantém a quantidade desejada de pods em execução.</li><li><strong>Services</strong>: expõem aplicações via ClusterIP, NodePort ou LoadBalancer.</li><li><strong>Volumes</strong>: armazenamento compartilhado/persistente para pods.</li><li><strong>Probes</strong>: checagens de saúde (<em>liveness</em>, <em>readiness</em>, <em>startup</em>).</li><li><strong>Ingress</strong>: regras HTTP/HTTPS para expor serviços com host/path/TLS.</li><li><strong>Secrets</strong>: dados sensíveis (tokens, senhas, chaves) em base64.</li><li><strong>ConfigMap</strong>: configurações não sensíveis em chave/valor.</li></ul><hr><p>Nos próximos posts da série, vou detalhar <strong>pods, deployments e services</strong>, com exemplos práticos e manifests reais.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://davidferreira21.github.io/blog/tags/k8s/>K8s</a></li><li><a href=https://davidferreira21.github.io/blog/tags/kubernetes/>Kubernetes</a></li><li><a href=https://davidferreira21.github.io/blog/tags/fundamentos/>Fundamentos</a></li><li><a href=https://davidferreira21.github.io/blog/tags/containers/>Containers</a></li><li><a href=https://davidferreira21.github.io/blog/tags/cloud/>Cloud</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://davidferreira21.github.io/blog/>David Ferreira — Cloud & Platform Engineering</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=custom-footer><div class=custom-footer__inner><div class=custom-footer__cta><p class=custom-footer__title>Quer receber atualizações?</p><p class=custom-footer__subtitle>Inscreva-se para não perder novos posts sobre cloud, arquitetura e devops.</p></div><form class=custom-footer__subscribe action=# method=post><label for=subscribe-email>Newsletter</label><div class=custom-footer__subscribe-row><input id=subscribe-email name=email type=email placeholder="Seu melhor e-mail" required>
<button type=submit>Assinar</button></div></form></div><div class=custom-footer__divider></div><div class=custom-footer__bottom><div class=custom-footer__brand><span class=custom-footer__name>David Ferreira — Cloud & Platform Engineering</span>
<span class=custom-footer__theme>Cloud • Platform Engineering • DevOps</span></div><div class=custom-footer__links><a class=custom-footer__link href=/blog/sobre/>Sobre mim</a>
<a class=custom-footer__link href=https://www.linkedin.com/in/davidferreirams/ rel=noopener target=_blank><span class=custom-footer__icon aria-hidden=true><svg viewBox="0 0 24 24" role="img" aria-label="LinkedIn"><path d="M20.45 20.45H17V14.86c0-1.33-.02-3.04-1.85-3.04-1.85.0-2.13 1.45-2.13 2.95v5.68H9.56V9h3.32v1.56h.05c.46-.88 1.58-1.8 3.26-1.8 3.49.0 4.13 2.3 4.13 5.29v6.4zM5.34 7.43a1.94 1.94.0 110-3.88 1.94 1.94.0 010 3.88zM6.95 20.45H3.72V9H6.95v11.45z"/></svg>
</span>LinkedIn</a></div></div></div><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>