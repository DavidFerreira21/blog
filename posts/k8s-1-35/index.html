<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes 1.35: principais mudanças e impactos | David Ferreira — Cloud & Platform Engineering</title>
<meta name=keywords content="k8s,kubernetes,release,v1.35,changelog"><meta name=description content="Resumo das mudanças mais relevantes do Kubernetes 1.35, com foco em deprecações e impactos operacionais."><meta name=author content><link rel=canonical href=https://davidferreira21.github.io/blog/posts/k8s-1-35/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.225c827f62bd46fb25dbd1b6603f2504b0525ff4ba1ee817c0a9e8253ebeb2f4.css integrity="sha256-IlyCf2K9Rvsl29G2YD8lBLBSX/S6HugXwKnoJT6+svQ=" rel="preload stylesheet" as=style><link rel=icon href=https://davidferreira21.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://davidferreira21.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://davidferreira21.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://davidferreira21.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://davidferreira21.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://davidferreira21.github.io/blog/posts/k8s-1-35/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://davidferreira21.github.io/blog/posts/k8s-1-35/"><meta property="og:site_name" content="David Ferreira — Cloud & Platform Engineering"><meta property="og:title" content="Kubernetes 1.35: principais mudanças e impactos"><meta property="og:description" content="Resumo das mudanças mais relevantes do Kubernetes 1.35, com foco em deprecações e impactos operacionais."><meta property="og:locale" content="pt-br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-29T23:18:29-03:00"><meta property="article:modified_time" content="2026-01-29T23:18:29-03:00"><meta property="article:tag" content="K8s"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Release"><meta property="article:tag" content="V1.35"><meta property="article:tag" content="Changelog"><meta property="og:image" content="https://davidferreira21.github.io/blog/images/k8s-1-35.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://davidferreira21.github.io/blog/images/k8s-1-35.png"><meta name=twitter:title content="Kubernetes 1.35: principais mudanças e impactos"><meta name=twitter:description content="Resumo das mudanças mais relevantes do Kubernetes 1.35, com foco em deprecações e impactos operacionais."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://davidferreira21.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes 1.35: principais mudanças e impactos","item":"https://davidferreira21.github.io/blog/posts/k8s-1-35/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes 1.35: principais mudanças e impactos","name":"Kubernetes 1.35: principais mudanças e impactos","description":"Resumo das mudanças mais relevantes do Kubernetes 1.35, com foco em deprecações e impactos operacionais.","keywords":["k8s","kubernetes","release","v1.35","changelog"],"articleBody":"Kubernetes 1.35: principais mudanças e impactos Este post é um resumo objetivo das mudanças mais relevantes do Kubernetes v1.35, com foco no que pode impactar clusters em produção.\nA versão 1.35 foi lançada em 17 de dezembro de 2025, então as mudanças abaixo já estão válidas para quem começou a atualizar ou planeja atualizar nos próximos ciclos.\nDeprecações e remoções (o que exige atenção) Remoção do cgroup v1 O suporte ao cgroup v1 foi removido. Se seus nós ainda usam distribuições antigas sem cgroup v2, o kubelet não inicia. A ação recomendada é migrar para cgroup v2 antes de atualizar o cluster.\nDepreciação do modo ipvs no kube-proxy O modo ipvs do kube-proxy foi depreciado. Ele ainda funciona nesta versão, mas gera aviso e o caminho recomendado é migrar para nftables.\nÚltima chamada para containerd 1.x O Kubernetes 1.35 é a última versão que suporta containerd 1.x. Antes de seguir para a próxima minor, é preciso migrar para containerd 2.0+.\nDestaques importantes do 1.35 Melhor estabilidade durante reinício do kubelet (GA) O kubelet agora restaura corretamente o estado dos containers após restart, evitando que Pods saudáveis sejam marcados como NotReady temporariamente. Isso reduz interrupções durante manutenção de nós.\nDRA sempre habilitado (GA) O Dynamic Resource Allocation (DRA) passa a ficar sempre habilitado no 1.35 (já estava estável no 1.34). Isso reforça o caminho para recursos avançados de hardware com melhor integração.\nIn-place Pod Resize (GA) Agora é possível ajustar CPU/memória de Pods em execução sem recriar o Pod. Isso reduz janelas de indisponibilidade em workloads stateful e simplifica operações de capacidade. É especialmente útil para picos sazonais e tuning rápido sem novas implantações.\nPod Certificates (beta) Introduz certificados nativos para workloads, com rotação automática. Reduz a dependência de controladores externos e sidecars para identidade de serviço. Também padroniza a emissão/renovação e melhora governança de credenciais no cluster.\nStorage version migration in-tree (beta, habilitado por padrão) A migração de storage version passa a ser integrada ao control plane, evitando ferramentas externas e simplificando upgrades. Isso reduz esforço operacional e torna a transição entre versões de API mais previsível.\nRestartPolicyRules por container (beta, habilitado por padrão) Permite regras de restart por container, evitando o reschedule do Pod inteiro em falhas localizadas. Ajuda a isolar falhas em sidecars e manter o Pod saudável quando apenas um container precisa reiniciar.\nTokens de CSI via secrets field (beta, opt-in) Drivers CSI podem receber tokens de ServiceAccount via secrets, reduzindo risco de vazamento em logs e melhorando a rastreabilidade. Isso também facilita políticas de segurança mais rígidas para armazenamento.\nTaints/tolerations com operadores numéricos (alpha) Habilita programação baseada em critérios numéricos, útil para políticas de SLA e qualidade de nós. Dá mais precisão para separar cargas por capacidade e qualidade do ambiente. Por ser alpha, requer feature gate para uso.\nTopologia no Downward API (beta) Novos labels de topologia passam a ser injetados automaticamente em Pods, impactando estratégias de observabilidade e auto-labeling. Isso facilita métricas por zona/região sem depender de webhooks ou mutações externas.\nNode declared features (alpha) Quando habilitado, os nós passam a declarar features suportadas, evitando scheduling em nós incompatíveis com recursos específicos. É um passo importante para clusters heterogêneos com hardwares distintos.\nDeployment terminatingReplicas (beta) O Deployment passa a expor quantos Pods estão em término (terminatingReplicas), facilitando a observabilidade de rollouts e detecção de stuck termination.\nStatefulSet maxUnavailable (beta, habilitado por padrão) Permite controlar quantos Pods de um StatefulSet podem ficar indisponíveis durante atualizações, acelerando upgrades com mais segurança.\nHPA tolerance configurável (beta, habilitado por padrão) O HPA passa a permitir ajustar a tolerância de escala por workload, evitando flapping e melhorando estabilidade de autoscaling.\nVerificação de credenciais para imagens em cache (beta, habilitado por padrão) Mesmo com a imagem já presente no nó, o kubelet valida credenciais antes de usá-la. Isso evita bypass de segurança em imagens privadas.\nUser namespaces em Pods (beta) Mapeia o root do container para UID não privilegiado no host, melhorando isolamento e segurança em ambientes multi-tenant.\nImage/OCI artifact volume (beta, habilitado por padrão) Permite entregar dados/binaries via imagens OCI sem init containers. Requer runtime compatível e simplifica distribuição de assets.\nMutable volume attach limits (beta, habilitado por padrão) O CSINode.allocatable.count torna-se dinâmico, reduzindo Pods presos em ContainerCreating por limites de attach desatualizados.\nmetadata.generation no Pod (GA) Introduz metadata.generation e status.observedGeneration para saber se o kubelet já processou mudanças no Pod.\nJob managedBy (GA) Permite delegar Jobs a outros controladores, útil para integrações com plataformas de batch e orquestração externa.\nSPDY -\u003e WebSockets (GA) Transição definitiva para WebSockets em kubectl exec/port-forward, reduzindo dependências legadas e melhorando compatibilidade.\nPreferSameNode Traffic Distribution (GA) Permite priorizar tráfego para endpoints no mesmo nó, reduzindo latência e custo de rede interna.\nNota do ecossistema (fora do escopo do 1.35) O projeto Ingress NGINX entrou em modo de manutenção limitada e será aposentado em março de 2026. A recomendação oficial é migrar para Gateway API ou outro controller ativo. Isso não é uma mudança do Kubernetes 1.35, mas é relevante para planejamento de rede em clusters atuais.\nChecklist rápido antes do upgrade Validar que todos os nós usam cgroup v2. Verificar runtime e atualizar containerd para 2.x. Migrar kube-proxy para nftables se ainda estiver em ipvs. Avaliar migração do Ingress NGINX para Gateway API. Existem outros updates menores além dos listados acima. Para mais detalhes, consulte a documentação oficial: https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/\n","wordCount":"885","inLanguage":"en","image":"https://davidferreira21.github.io/blog/images/k8s-1-35.png","datePublished":"2026-01-29T23:18:29-03:00","dateModified":"2026-01-29T23:18:29-03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://davidferreira21.github.io/blog/posts/k8s-1-35/"},"publisher":{"@type":"Organization","name":"David Ferreira — Cloud \u0026 Platform Engineering","logo":{"@type":"ImageObject","url":"https://davidferreira21.github.io/blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://davidferreira21.github.io/blog/ accesskey=h title="David Ferreira — Cloud & Platform Engineering (Alt + H)">David Ferreira — Cloud & Platform Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://davidferreira21.github.io/blog/ title=Início><span>Início</span></a></li><li><a href=https://davidferreira21.github.io/blog/posts/ title=Posts><span>Posts</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=arquitetura" title=Arquitetura><span>Arquitetura</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=cloud" title=Cloud><span>Cloud</span></a></li><li><a href="https://davidferreira21.github.io/blog/posts/?cat=devops" title=DevOps><span>DevOps</span></a></li><li><a href=https://davidferreira21.github.io/blog/sobre/ title=Sobre><span>Sobre</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kubernetes 1.35: principais mudanças e impactos</h1><div class=post-description>Resumo das mudanças mais relevantes do Kubernetes 1.35, com foco em deprecações e impactos operacionais.</div><div class=post-meta><span title='2026-01-29 23:18:29 -0300 -0300'>January 29, 2026</span>&nbsp;·&nbsp;<span>5 min</span></div></header><figure class=entry-cover><img loading=eager src=https://davidferreira21.github.io/blog/images/k8s-1-35.png alt="Ilustração sobre novidades do Kubernetes 1.35"></figure><div class=post-content><h1 id=kubernetes-135-principais-mudanças-e-impactos>Kubernetes 1.35: principais mudanças e impactos<a hidden class=anchor aria-hidden=true href=#kubernetes-135-principais-mudanças-e-impactos>#</a></h1><p>Este post é um resumo objetivo das mudanças mais relevantes do Kubernetes <strong>v1.35</strong>, com foco no que pode impactar clusters em produção.</p><p>A versão 1.35 foi lançada em <strong>17 de dezembro de 2025</strong>, então as mudanças abaixo já estão válidas para quem começou a atualizar ou planeja atualizar nos próximos ciclos.</p><h2 id=deprecações-e-remoções-o-que-exige-atenção>Deprecações e remoções (o que exige atenção)<a hidden class=anchor aria-hidden=true href=#deprecações-e-remoções-o-que-exige-atenção>#</a></h2><h3 id=remoção-do-cgroup-v1>Remoção do cgroup v1<a hidden class=anchor aria-hidden=true href=#remoção-do-cgroup-v1>#</a></h3><p>O suporte ao <strong>cgroup v1</strong> foi removido. Se seus nós ainda usam distribuições antigas sem cgroup v2, o <strong>kubelet não inicia</strong>. A ação recomendada é migrar para cgroup v2 antes de atualizar o cluster.</p><h3 id=depreciação-do-modo-ipvs-no-kube-proxy>Depreciação do modo ipvs no kube-proxy<a hidden class=anchor aria-hidden=true href=#depreciação-do-modo-ipvs-no-kube-proxy>#</a></h3><p>O modo <strong>ipvs</strong> do kube-proxy foi depreciado. Ele ainda funciona nesta versão, mas gera aviso e o caminho recomendado é migrar para <strong>nftables</strong>.</p><h3 id=última-chamada-para-containerd-1x>Última chamada para containerd 1.x<a hidden class=anchor aria-hidden=true href=#última-chamada-para-containerd-1x>#</a></h3><p>O Kubernetes 1.35 é a <strong>última versão</strong> que suporta containerd <strong>1.x</strong>. Antes de seguir para a próxima minor, é preciso migrar para <strong>containerd 2.0+</strong>.</p><h2 id=destaques-importantes-do-135>Destaques importantes do 1.35<a hidden class=anchor aria-hidden=true href=#destaques-importantes-do-135>#</a></h2><h3 id=melhor-estabilidade-durante-reinício-do-kubelet-ga>Melhor estabilidade durante reinício do kubelet (GA)<a hidden class=anchor aria-hidden=true href=#melhor-estabilidade-durante-reinício-do-kubelet-ga>#</a></h3><p>O kubelet agora restaura corretamente o estado dos containers após restart, evitando que Pods saudáveis sejam marcados como <code>NotReady</code> temporariamente. Isso reduz interrupções durante manutenção de nós.</p><h3 id=dra-sempre-habilitado-ga>DRA sempre habilitado (GA)<a hidden class=anchor aria-hidden=true href=#dra-sempre-habilitado-ga>#</a></h3><p>O <strong>Dynamic Resource Allocation (DRA)</strong> passa a ficar sempre habilitado no 1.35 (já estava estável no 1.34). Isso reforça o caminho para recursos avançados de hardware com melhor integração.</p><h3 id=in-place-pod-resize-ga>In-place Pod Resize (GA)<a hidden class=anchor aria-hidden=true href=#in-place-pod-resize-ga>#</a></h3><p>Agora é possível ajustar CPU/memória de Pods em execução sem recriar o Pod. Isso reduz janelas de indisponibilidade em workloads stateful e simplifica operações de capacidade. É especialmente útil para picos sazonais e tuning rápido sem novas implantações.</p><h3 id=pod-certificates-beta>Pod Certificates (beta)<a hidden class=anchor aria-hidden=true href=#pod-certificates-beta>#</a></h3><p>Introduz certificados nativos para workloads, com rotação automática. Reduz a dependência de controladores externos e sidecars para identidade de serviço. Também padroniza a emissão/renovação e melhora governança de credenciais no cluster.</p><h3 id=storage-version-migration-in-tree-beta-habilitado-por-padrão>Storage version migration in-tree (beta, habilitado por padrão)<a hidden class=anchor aria-hidden=true href=#storage-version-migration-in-tree-beta-habilitado-por-padrão>#</a></h3><p>A migração de storage version passa a ser integrada ao control plane, evitando ferramentas externas e simplificando upgrades. Isso reduz esforço operacional e torna a transição entre versões de API mais previsível.</p><h3 id=restartpolicyrules-por-container-beta-habilitado-por-padrão>RestartPolicyRules por container (beta, habilitado por padrão)<a hidden class=anchor aria-hidden=true href=#restartpolicyrules-por-container-beta-habilitado-por-padrão>#</a></h3><p>Permite regras de restart por container, evitando o reschedule do Pod inteiro em falhas localizadas. Ajuda a isolar falhas em sidecars e manter o Pod saudável quando apenas um container precisa reiniciar.</p><h3 id=tokens-de-csi-via-secrets-field-beta-opt-in>Tokens de CSI via secrets field (beta, opt-in)<a hidden class=anchor aria-hidden=true href=#tokens-de-csi-via-secrets-field-beta-opt-in>#</a></h3><p>Drivers CSI podem receber tokens de ServiceAccount via <code>secrets</code>, reduzindo risco de vazamento em logs e melhorando a rastreabilidade. Isso também facilita políticas de segurança mais rígidas para armazenamento.</p><h3 id=taintstolerations-com-operadores-numéricos-alpha>Taints/tolerations com operadores numéricos (alpha)<a hidden class=anchor aria-hidden=true href=#taintstolerations-com-operadores-numéricos-alpha>#</a></h3><p>Habilita programação baseada em critérios numéricos, útil para políticas de SLA e qualidade de nós. Dá mais precisão para separar cargas por capacidade e qualidade do ambiente. Por ser alpha, requer feature gate para uso.</p><h3 id=topologia-no-downward-api-beta>Topologia no Downward API (beta)<a hidden class=anchor aria-hidden=true href=#topologia-no-downward-api-beta>#</a></h3><p>Novos labels de topologia passam a ser injetados automaticamente em Pods, impactando estratégias de observabilidade e auto-labeling. Isso facilita métricas por zona/região sem depender de webhooks ou mutações externas.</p><h3 id=node-declared-features-alpha>Node declared features (alpha)<a hidden class=anchor aria-hidden=true href=#node-declared-features-alpha>#</a></h3><p>Quando habilitado, os nós passam a declarar features suportadas, evitando scheduling em nós incompatíveis com recursos específicos. É um passo importante para clusters heterogêneos com hardwares distintos.</p><h3 id=deployment-terminatingreplicas-beta>Deployment terminatingReplicas (beta)<a hidden class=anchor aria-hidden=true href=#deployment-terminatingreplicas-beta>#</a></h3><p>O Deployment passa a expor quantos Pods estão em término (<code>terminatingReplicas</code>), facilitando a observabilidade de rollouts e detecção de stuck termination.</p><h3 id=statefulset-maxunavailable-beta-habilitado-por-padrão>StatefulSet maxUnavailable (beta, habilitado por padrão)<a hidden class=anchor aria-hidden=true href=#statefulset-maxunavailable-beta-habilitado-por-padrão>#</a></h3><p>Permite controlar quantos Pods de um StatefulSet podem ficar indisponíveis durante atualizações, acelerando upgrades com mais segurança.</p><h3 id=hpa-tolerance-configurável-beta-habilitado-por-padrão>HPA tolerance configurável (beta, habilitado por padrão)<a hidden class=anchor aria-hidden=true href=#hpa-tolerance-configurável-beta-habilitado-por-padrão>#</a></h3><p>O HPA passa a permitir ajustar a tolerância de escala por workload, evitando flapping e melhorando estabilidade de autoscaling.</p><h3 id=verificação-de-credenciais-para-imagens-em-cache-beta-habilitado-por-padrão>Verificação de credenciais para imagens em cache (beta, habilitado por padrão)<a hidden class=anchor aria-hidden=true href=#verificação-de-credenciais-para-imagens-em-cache-beta-habilitado-por-padrão>#</a></h3><p>Mesmo com a imagem já presente no nó, o kubelet valida credenciais antes de usá-la. Isso evita bypass de segurança em imagens privadas.</p><h3 id=user-namespaces-em-pods-beta>User namespaces em Pods (beta)<a hidden class=anchor aria-hidden=true href=#user-namespaces-em-pods-beta>#</a></h3><p>Mapeia o root do container para UID não privilegiado no host, melhorando isolamento e segurança em ambientes multi-tenant.</p><h3 id=imageoci-artifact-volume-beta-habilitado-por-padrão>Image/OCI artifact volume (beta, habilitado por padrão)<a hidden class=anchor aria-hidden=true href=#imageoci-artifact-volume-beta-habilitado-por-padrão>#</a></h3><p>Permite entregar dados/binaries via imagens OCI sem init containers. Requer runtime compatível e simplifica distribuição de assets.</p><h3 id=mutable-volume-attach-limits-beta-habilitado-por-padrão>Mutable volume attach limits (beta, habilitado por padrão)<a hidden class=anchor aria-hidden=true href=#mutable-volume-attach-limits-beta-habilitado-por-padrão>#</a></h3><p>O <code>CSINode.allocatable.count</code> torna-se dinâmico, reduzindo Pods presos em <code>ContainerCreating</code> por limites de attach desatualizados.</p><h3 id=metadatageneration-no-pod-ga>metadata.generation no Pod (GA)<a hidden class=anchor aria-hidden=true href=#metadatageneration-no-pod-ga>#</a></h3><p>Introduz <code>metadata.generation</code> e <code>status.observedGeneration</code> para saber se o kubelet já processou mudanças no Pod.</p><h3 id=job-managedby-ga>Job managedBy (GA)<a hidden class=anchor aria-hidden=true href=#job-managedby-ga>#</a></h3><p>Permite delegar Jobs a outros controladores, útil para integrações com plataformas de batch e orquestração externa.</p><h3 id=spdy---websockets-ga>SPDY -> WebSockets (GA)<a hidden class=anchor aria-hidden=true href=#spdy---websockets-ga>#</a></h3><p>Transição definitiva para WebSockets em <code>kubectl exec/port-forward</code>, reduzindo dependências legadas e melhorando compatibilidade.</p><h3 id=prefersamenode-traffic-distribution-ga>PreferSameNode Traffic Distribution (GA)<a hidden class=anchor aria-hidden=true href=#prefersamenode-traffic-distribution-ga>#</a></h3><p>Permite priorizar tráfego para endpoints no mesmo nó, reduzindo latência e custo de rede interna.</p><h2 id=nota-do-ecossistema-fora-do-escopo-do-135>Nota do ecossistema (fora do escopo do 1.35)<a hidden class=anchor aria-hidden=true href=#nota-do-ecossistema-fora-do-escopo-do-135>#</a></h2><p>O projeto <strong>Ingress NGINX</strong> entrou em <strong>modo de manutenção limitada</strong> e será aposentado em <strong>março de 2026</strong>. A recomendação oficial é migrar para <strong>Gateway API</strong> ou outro controller ativo. Isso <strong>não é uma mudança do Kubernetes 1.35</strong>, mas é relevante para planejamento de rede em clusters atuais.</p><h2 id=checklist-rápido-antes-do-upgrade>Checklist rápido antes do upgrade<a hidden class=anchor aria-hidden=true href=#checklist-rápido-antes-do-upgrade>#</a></h2><ul><li>Validar que <strong>todos os nós</strong> usam cgroup v2.</li><li>Verificar runtime e atualizar <strong>containerd para 2.x</strong>.</li><li>Migrar <code>kube-proxy</code> para <strong>nftables</strong> se ainda estiver em ipvs.</li><li>Avaliar migração do <strong>Ingress NGINX</strong> para Gateway API.</li></ul><hr><p>Existem outros updates menores além dos listados acima. Para mais detalhes, consulte a documentação oficial: <a href=https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/>https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://davidferreira21.github.io/blog/tags/k8s/>K8s</a></li><li><a href=https://davidferreira21.github.io/blog/tags/kubernetes/>Kubernetes</a></li><li><a href=https://davidferreira21.github.io/blog/tags/release/>Release</a></li><li><a href=https://davidferreira21.github.io/blog/tags/v1.35/>V1.35</a></li><li><a href=https://davidferreira21.github.io/blog/tags/changelog/>Changelog</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=custom-footer><div class=custom-footer__inner><div class=custom-footer__cta><p class=custom-footer__title>Quer receber atualizações?</p><p class=custom-footer__subtitle>Inscreva-se para não perder novos posts sobre cloud, arquitetura e devops.</p></div><form class=custom-footer__subscribe action=# method=post><label for=subscribe-email>Newsletter</label><div class=custom-footer__subscribe-row><input id=subscribe-email name=email type=email placeholder="Seu melhor e-mail" required>
<button type=submit>Assinar</button></div></form></div><div class=custom-footer__divider></div><div class=custom-footer__bottom><div class=custom-footer__brand><span class=custom-footer__name>David Ferreira — Cloud & Platform Engineering</span>
<span class=custom-footer__theme>Cloud • Platform Engineering • DevOps</span></div><div class=custom-footer__links><a class=custom-footer__link href=/blog/sobre/>Sobre mim</a>
<a class=custom-footer__link href=https://www.linkedin.com/in/davidferreirams/ rel=noopener target=_blank><span class=custom-footer__icon aria-hidden=true><svg viewBox="0 0 24 24" role="img" aria-label="LinkedIn"><path d="M20.45 20.45H17V14.86c0-1.33-.02-3.04-1.85-3.04-1.85.0-2.13 1.45-2.13 2.95v5.68H9.56V9h3.32v1.56h.05c.46-.88 1.58-1.8 3.26-1.8 3.49.0 4.13 2.3 4.13 5.29v6.4zM5.34 7.43a1.94 1.94.0 110-3.88 1.94 1.94.0 010 3.88zM6.95 20.45H3.72V9H6.95v11.45z"/></svg>
</span>LinkedIn</a></div></div></div><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>